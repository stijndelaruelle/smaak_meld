using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#if UNITY_EDITOR
    using UnityEditor;
#endif

[RequireComponent(typeof(MeshFilter))]
public class Road : MonoBehaviour
{
    [SerializeField]
    private bool m_Debug = false;
    private Mesh m_Mesh;

    public void GenerateWaypoints(List<Waypoint> waypointList, Waypoint waypointPrefab)
    {
        m_Mesh = GetComponent<MeshFilter>().sharedMesh;

        //Runtime generated
        if (m_Mesh.name == "New Game Object")
        {
            GenerateWaypointsPreSerialization(waypointList, waypointPrefab);
        }

        //From OBJ
        else
        {
            GenerateWaypointsPostSerialization(waypointList, waypointPrefab);
        }
    }

    public void GenerateWaypointsPreSerialization(List<Waypoint> waypointList, Waypoint waypointPrefab)
    {
        m_Mesh = GetComponent<MeshFilter>().sharedMesh;

        Vector3[] vertices = m_Mesh.vertices;
        int[] indices = m_Mesh.triangles;

        //In an unoptimized obj the vertices and indices relate like this.
        //---------------------------------------------------------------------
        //In the first triangle the waypoint should be placed between the 3rd (i + 2) and 1st (i + 0) point in the triangle
        //In the second triangle the waypoint should be placed between the 1st (i + 0) and 2nd (i + 1) point in the triangle

        //Apart from the first and last triangle these overlap 100%
        //Because of this I'm only placing waypoints every other triangle, except for the last triangle

        Waypoint newWaypoint = null;
        for (int i = 0; i < indices.Length; i += 6)
        {
            newWaypoint = SpawnWaypoint(vertices[indices[i + 2]], vertices[indices[i + 0]], waypointPrefab);
            waypointList.Add(newWaypoint);
        }

        //Last waypoint at the end of the mesh
        Vector3 thirdLastVertexPosition = vertices[indices[indices.Length - 3]];
        Vector3 secondLastVertexPosition = vertices[indices[indices.Length - 2]];

        newWaypoint = SpawnWaypoint(thirdLastVertexPosition, secondLastVertexPosition, waypointPrefab);
        waypointList.Add(newWaypoint);
    }

    public void GenerateWaypointsPostSerialization(List<Waypoint> waypointList, Waypoint waypointPrefab)
    {
        m_Mesh = GetComponent<MeshFilter>().sharedMesh;

        Vector3[] vertices = m_Mesh.vertices;
        int[] indices = m_Mesh.triangles;

        //AFTER saving to an obj the vertices and indices relate like this.
        //---------------------------------------------------------------------
        //In the first triangle the waypoint should be placed between the 2nd (i + 1) and 3rd (i + 2) point in the triangle
        //In the second triangle the waypoint should be placed between the 3rd (i + 2) and 1st (i + 0) point in the triangle

        //Apart from the first and last triangle these overlap 100%
        //Because of this I'm only placing waypoints every other triangle, except for the last triangle

        Waypoint newWaypoint = null;
        for (int i = 0; i < indices.Length; i += 6)
        {
            newWaypoint = SpawnWaypoint(vertices[indices[i + 1]], vertices[indices[i + 2]], waypointPrefab);
            waypointList.Add(newWaypoint);
        }

        //Last waypoint at the end of the mesh
        Vector3 thirdLastVertexPosition = vertices[indices[indices.Length - 3]];
        Vector3 lastVertexPosition = vertices[indices[indices.Length - 1]];

        newWaypoint = SpawnWaypoint(thirdLastVertexPosition, lastVertexPosition, waypointPrefab);
        waypointList.Add(newWaypoint);
    }

    private Waypoint SpawnWaypoint(Vector3 vertex1, Vector3 vertex2, Waypoint waypointPrefab)
    {
        //Get the world space of these 2 vertices
        Vector3 position1 = transform.TransformPoint(vertex1);
        Vector3 position2 = transform.TransformPoint(vertex2);

        //Calculate the average
        Vector3 average = (position1 + position2) / 2.0f;

        //Spawn a waypoint at the average
        return GameObject.Instantiate(waypointPrefab, average, Quaternion.identity, this.transform) as Waypoint;
    }

#if UNITY_EDITOR
    private void OnDrawGizmos()
    {
        if (!m_Debug)
            return;

        //Show the indices at the vertices. Useful while figuring out how the triangles are generated by MapBox
        Mesh mesh = GetComponent<MeshFilter>().sharedMesh;

        Vector3[] vertices = mesh.vertices;
        int[] triangles = mesh.triangles;

        List<int> usedIndices = new List<int>();

        GUIStyle yellowText = new GUIStyle();
        yellowText.normal.textColor = Color.yellow;

        //Draw indices
        for (int i = 0; i < triangles.Length; ++i)
        {
            int index = triangles[i];
            Vector3 worldPosition = transform.TransformPoint(vertices[index]);

            //Avoid duplicate drawing
            if (usedIndices.Contains(index))
                continue;

            Handles.Label(worldPosition, index.ToString(), yellowText);
            usedIndices.Add(index);
        }
    }
#endif

}
