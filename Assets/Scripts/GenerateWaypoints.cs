using System.Collections;
using System.Collections.Generic;
using UnityEngine;

#if UNITY_EDITOR
    using UnityEditor;
#endif

[RequireComponent(typeof(MeshFilter))]
public class GenerateWaypoints : MonoBehaviour
{
    [SerializeField]
    private GameObject m_WaypointPrefab;

    //debug purposes, delete
    private Vector3[] m_Vertices;
    private int[] m_Indices;

    private void Start()
    {
        Generate();
    }

    private void Generate()
    {
        Mesh mesh = GetComponent<MeshFilter>().sharedMesh;

        m_Vertices = mesh.vertices;
        m_Indices = mesh.triangles;

        //In the first triangle the waypoint should be placed between the 2nd (i + 1) and 3rd (i + 2) point in the triangle
        //In the second triangle the waypoint should be placed between the 3rd (i + 2) and 1st (i + 0) point in the triangle

        //Apart from the first and last triangle these overlap 100%
        //Because of this I'm only placing waypoints every other triangle, except for the last triangle
        for (int i = 0; i < m_Indices.Length; i += 6)
        {
            SpawnWaypoint(m_Vertices[m_Indices[i + 1]], m_Vertices[m_Indices[i + 2]]);
        }

        //Last waypoint at the end of the mesh
        Vector3 thirdLastVertexPosition = m_Vertices[m_Indices[m_Indices.Length - 3]];
        Vector3 lastVertexPosition = m_Vertices[m_Indices[m_Indices.Length - 1]];

        SpawnWaypoint(thirdLastVertexPosition, lastVertexPosition);
    }

    private void SpawnWaypoint(Vector3 vertex1, Vector3 vertex2)
    {
        //Get the world space of these 2 vertices
        Vector3 position1 = this.transform.position + vertex1;
        Vector3 position2 = this.transform.position + vertex2;

        //Calculate the average
        Vector3 average = (position1 + position2) / 2.0f;

        //Spawn a waypoint at the average
        GameObject.Instantiate(m_WaypointPrefab, average, Quaternion.identity, this.transform);
    }

#if UNITY_EDITOR
    private void OnDrawGizmos()
    {
        //Show the indices at the vertices. Useful while figuring out how the triangles are generated by MapBox
        Mesh mesh = GetComponent<MeshFilter>().sharedMesh;

        Vector3[] vertices = mesh.vertices;
        int[] triangles = mesh.triangles;

        List<int> usedIndices = new List<int>();

        GUIStyle yellowText = new GUIStyle();
        yellowText.normal.textColor = Color.yellow;

        //Draw indices
        for (int i = 0; i < triangles.Length; ++i)
        {
            int index = triangles[i];
            Vector3 unscaledPosition = transform.position + vertices[index];

            //Avoid duplicate drawing
            if (usedIndices.Contains(index))
                continue;

            Handles.Label(unscaledPosition, index.ToString(), yellowText);
            usedIndices.Add(index);
        }
    }
}
#endif